<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Poker Stack Logger</title>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <style>
    :root {
      --bg:#fff;
      --card:#fff;
      --bd:#e6e6e6;
      --muted:#666;
      --text:#111;
      --soft:#f6f6f6;
      --soft2:#f1f1f1;
      --accent:#111;
      --ok:#0b7;
      --warn:#f7b;
    }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; margin: 0; background:var(--bg); color:var(--text); }
    header { position: sticky; top:0; z-index:20; background: rgba(255,255,255,0.92); backdrop-filter: blur(12px); border-bottom:1px solid var(--bd); }
    .wrap { padding: 12px 14px 80px; max-width: 980px; margin: 0 auto; }
    h1 { font-size: 16px; margin: 10px 0 8px; }
    h2 { font-size: 14px; margin: 0 0 8px; color: #222; }

    /* Tabs */
    .tabs { display:flex; gap:8px; padding: 10px 14px; overflow:auto; }
    .tab {
      flex: 0 0 auto;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--bd);
      background: var(--soft);
      color:#111;
      font-size: 14px;
      line-height: 1;
      user-select:none;
    }
    .tab.active { background: var(--accent); color:#fff; border-color: var(--accent); }

    /* Pages */
    .pages { position: relative; }
    .page { display:none; }
    .page.active { display:block; }

    .card { border:1px solid var(--bd); border-radius: 14px; padding: 12px; margin: 12px 0; background:var(--card); }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end; }
    label { font-size: 12px; color: #444; display:block; margin-bottom:4px; }
    input, select, button, textarea { font-size: 16px; padding: 10px; border-radius: 12px; border:1px solid #cfcfcf; background:#fff; }
    input { width: 180px; }
    input.small { width: 120px; }
    select { width: 220px; }
    textarea { width: 100%; min-height: 72px; resize: vertical; }
    button { border:0; cursor:pointer; }
    .btn { padding: 12px 14px; border-radius: 12px; }
    .btn-primary { background:#111; color:#fff; }
    .btn-ghost { background: var(--soft); color:#111; border:1px solid var(--bd); }
    .btn-danger { background:#ffecec; color:#111; border:1px solid #ffd0d0; }
    .btn-mini { padding: 10px 10px; font-size: 14px; border-radius: 12px; border:1px solid var(--bd); background: var(--soft); }
    .btn-step { min-width: 88px; text-align:center; font-variant-numeric: tabular-nums; font-feature-settings:"tnum"; }

    .hint { font-size: 12px; color: var(--muted); line-height: 1.45; }
    .mono { font-variant-numeric: tabular-nums; font-feature-settings:"tnum"; }
    .big { font-size: 34px; font-weight: 850; letter-spacing: 0.4px; font-variant-numeric: tabular-nums; font-feature-settings:"tnum"; }

    .metrics { display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .metric { font-size: 13px; color:#333; }
    .metric b { font-size: 20px; font-variant-numeric: tabular-nums; font-feature-settings:"tnum"; }

    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background: var(--soft); border:1px solid var(--bd); font-size: 12px; }

    .auto-off { opacity: 0.55; background: var(--soft2) !important; }
    .checkline { display:flex; align-items:center; gap:8px; margin-top: 4px; }
    .checkline input[type="checkbox"] { width:auto; padding:0; transform: scale(1.1); }

    /* Toast */
    .toast {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(17,17,17,0.92);
      color: #fff;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      display: none;
      z-index: 50;
      max-width: 92vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .toast.show { display:block; animation: pop 0.18s ease-out; }
    @keyframes pop { from { transform: translateX(-50%) translateY(8px); opacity:0; } to { transform: translateX(-50%) translateY(0); opacity:1; } }

    /* Chart */
    canvas { width: 100%; height: 300px; border-radius: 14px; background:#fafafa; border:1px solid #eee; display:block; }

    /* Table */
    table { width:100%; border-collapse: collapse; }
    th, td { border-top:1px solid #eee; padding:10px 6px; font-size: 13px; vertical-align: top; }
    th { text-align:left; color:#555; font-weight:600; position: sticky; top: 62px; background: white; z-index: 10; }
    .right { text-align:right; }

    /* Power grid */
    .powerBox { display:grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 860px){ .powerBox { grid-template-columns: 1.2fr 0.8fr; } }

    .gridWrap { overflow:auto; border:1px solid var(--bd); border-radius: 14px; }
    .handGrid { border-collapse: collapse; width: max-content; min-width: 520px; }
    .handGrid th, .handGrid td {
      border: 1px solid #e8e8e8;
      padding: 6px 8px;
      font-size: 12px;
      text-align: center;
      white-space: nowrap;
    }
    .handGrid th { background: #f9f9f9; position: sticky; top:0; z-index:2; }
    .handGrid th.left { left:0; z-index:3; position: sticky; }
    .handGrid td.left { left:0; z-index:1; position: sticky; background:#fff; font-weight:600; }
    .cellHi { outline: 2px solid #111; outline-offset: -2px; background: #fff2cc; }
    .cellAI { background: #ffecec; font-weight:800; }
    .cellLow { color:#999; }
    .smallNote { font-size: 12px; color: #666; }
    .textBtn { width: 100%; text-align:left; }
    .textAreaSmall { min-height: 140px; }

    /* Swipe hint */
    .swipeHint { font-size: 12px; color:#777; margin-top: 2px; }
  </style>
</head>
<body>

<header>
  <div class="wrap" style="padding-bottom:0;">
    <h1>Poker Stack Logger（最終版）</h1>
  </div>
  <div class="tabs" id="tabs">
    <div class="tab active" data-page="input">入力</div>
    <div class="tab" data-page="chart">グラフ</div>
    <div class="tab" data-page="logs">ログ</div>
    <div class="tab" data-page="power">パワー</div>
  </div>
</header>

<div class="wrap">
  <!-- TOP summary (共通表示) -->
  <div class="card">
    <div class="row" style="justify-content: space-between; align-items:center;">
      <div>
        <div class="hint">現在Chips</div>
        <div class="big mono" id="chipsBig">0</div>
      </div>
      <div class="metrics">
        <div class="metric">Dif Chips：<b id="difChips" class="mono">-</b></div>
        <div class="metric">M Value：<b id="mValue" class="mono">-</b></div>
        <div class="metric">Num Behind：<b id="behind" class="mono">-</b></div>
        <div class="metric">Power：<b id="powerNum" class="mono">-</b></div>
      </div>
    </div>
    <div class="hint" style="margin-top:8px;">
      Dif = Chips − Initial − (Busted×Initial) ／ M = Chips ÷ (SB + BB + BB ante) ／ Power = M × (Num Behind)
    </div>
  </div>

  <div class="pages" id="pages">

    <!-- ===== Input Page ===== -->
    <section class="page active" id="page-input">
      <div class="card">
        <h2>インプット</h2>

        <div class="row">
          <div>
            <label>Name（自由記述）</label>
            <input id="name" placeholder="例）12/25 Xmasトナメ" />
          </div>
          <div>
            <label>Chips（現在）</label>
            <input id="chips" type="number" inputmode="numeric" min="0" step="1" />
          </div>
        </div>

        <!-- Chip step buttons directly under Chips -->
        <div style="height:10px;"></div>
        <div class="row" style="align-items:center;">
          <div class="pill">増減（Chipsのすぐ下）</div>
          <div class="hint">押している間に単位が変わらないよう、候補は「Chips手入力」または「記録」の時だけ更新</div>
        </div>
        <div class="row" id="stepButtons" style="margin-top:6px;">
          <!-- JS inject: -A -B -C +C +B +A -->
        </div>

        <div style="height:14px;"></div>

        <div class="row">
          <div>
            <label>Initial Chips（初期スタック）</label>
            <input id="initial" class="small" type="number" inputmode="numeric" min="0" step="1" />
          </div>

          <div>
            <label>飛んだ回数（Busted）</label>
            <div class="row" style="gap:8px; align-items:center;">
              <button class="btn-mini" id="bustedMinus">−</button>
              <input id="busted" class="small" type="number" inputmode="numeric" min="0" step="1" />
              <button class="btn-mini" id="bustedPlus">＋</button>
            </div>
          </div>
        </div>

        <div style="height:10px;"></div>

        <div class="row">
          <div>
            <label>SB</label>
            <input id="sb" class="small" type="number" inputmode="numeric" min="0" step="1" />
          </div>
          <div>
            <label>BB</label>
            <input id="bb" class="small" type="number" inputmode="numeric" min="1" step="1" />
            <div class="checkline">
              <input type="checkbox" id="bbIs2sb" />
              <span class="hint">BB = 2×SB</span>
            </div>
          </div>
          <div>
            <label>BB ante</label>
            <input id="bbante" class="small" type="number" inputmode="numeric" min="0" step="1" />
            <div class="checkline">
              <input type="checkbox" id="anteIsBb" />
              <span class="hint">BB ante = BB</span>
            </div>
          </div>
        </div>

        <div style="height:10px;"></div>

        <div>
          <label>メモ（何があって変動したか）</label>
          <textarea id="memo" placeholder="例）BTNでAQsオールイン勝ち / SBでリスチ負け など"></textarea>
        </div>

        <div style="height:10px;"></div>

        <div class="row">
          <button class="btn btn-primary" id="record">記録（ログ追加）</button>
          <button class="btn btn-ghost" id="undo">直近ログを削除</button>
          <button class="btn btn-danger" id="clearAll">全消去</button>
        </div>

        <div class="swipeHint">※ 画面端からのスワイプはiPhoneの戻る操作と干渉する場合があります。中央付近から左右にスワイプしてください。</div>
      </div>
    </section>

    <!-- ===== Chart Page ===== -->
    <section class="page" id="page-chart">
      <div class="card">
        <h2>推移グラフ（Chipsのみ）</h2>

        <div class="row" style="margin: 8px 0 10px;">
          <div>
            <label>表示：Name</label>
            <select id="chartName" style="width: 260px;"></select>
          </div>
          <div>
            <label>表示：Date</label>
            <select id="chartDate" style="width: 200px;"></select>
          </div>
          <div style="flex:1"></div>
          <button class="btn btn-ghost" id="chartReset">表示リセット</button>
        </div>

        <canvas id="chart"></canvas>

        <div class="hint" style="margin-top:8px;">
          縦軸：Chips（レンジは 0〜2×Initial を基本に、突き抜けそうなら自動拡張）／ 横軸：記録時刻
        </div>
      </div>
    </section>

    <!-- ===== Logs Page ===== -->
    <section class="page" id="page-logs">
      <div class="card">
        <div class="row" style="justify-content: space-between; align-items:center;">
          <h2 style="margin:0;">アウトプット（ログ一覧）</h2>
          <div class="pill">最新が上</div>
        </div>

        <div class="row" style="margin-top:8px;">
          <button class="btn btn-ghost" id="copyCsv">CSVをコピー（ログ一覧）</button>
          <div style="flex:1"></div>
          <button class="btn btn-danger" id="exportJson">バックアップJSON（保存）</button>
          <button class="btn btn-ghost" id="importJson">復元JSON（読込）</button>
        </div>

        <div class="hint" style="margin-top:8px;">
          ※ OneDriveへ自動アップロードは、ブラウザだけで任意アカウントに直接保存するには認証が必要です（Power Automate等で対応可能）。
        </div>

        <div style="overflow:auto; max-height: 520px; margin-top:10px;">
          <table>
            <thead>
              <tr>
                <th>Name</th>
                <th>Date</th>
                <th>Time</th>
                <th class="right">Chips</th>
                <th class="right">Initial</th>
                <th class="right">Busted</th>
                <th class="right">Dif</th>
                <th class="right">SB</th>
                <th class="right">BB</th>
                <th class="right">Ante</th>
                <th class="right">M</th>
                <th>Memo</th>
              </tr>
            </thead>
            <tbody id="logBody"></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- ===== Power Page ===== -->
    <section class="page" id="page-power">
      <div class="card">
        <h2>パワー（M × 後ろ人数）＆ オールイン表</h2>

        <div class="row">
          <div>
            <label>Position（ここに移動）</label>
            <select id="position">
              <option>UTG</option>
              <option>UTG+1</option>
              <option>LJ</option>
              <option>HJ</option>
              <option>CO</option>
              <option>BTN</option>
              <option>SB</option>
              <option>BB</option>
            </select>
            <div class="hint">※ 8人MAX想定（table maxは削除）</div>
          </div>
          <div>
            <label>Num Behind（自動）</label>
            <input id="behindRead" class="small auto-off" disabled />
          </div>
          <div>
            <label>M（自動）</label>
            <input id="mRead" class="small auto-off" disabled />
          </div>
          <div>
            <label>Power（自動）</label>
            <input id="powerRead" class="small auto-off" disabled />
          </div>
        </div>

        <div class="powerBox" style="margin-top:10px;">
          <div class="gridWrap">
            <table class="handGrid" id="handGrid"></table>
          </div>

          <div class="card" style="margin:0;">
            <h2 style="margin-bottom:6px;">表データの貼り付け（自分用）</h2>
            <div class="hint">
              この表（数値表）は書籍等の著作物である可能性が高いため、アプリに初期値として同梱しません。<br>
              あなたが所持する資料から「自分用に」数値を貼り付ければ、Power以上のマスをハイライトします。
            </div>
            <div style="height:8px;"></div>
            <button class="btn btn-ghost textBtn" id="showPaste">
              ▶ ここを押して貼り付け欄を開く（TSV/CSV）
            </button>
            <div id="pasteArea" style="display:none; margin-top:8px;">
              <textarea id="gridPaste" class="textAreaSmall" placeholder=
"貼り付け例（TSV推奨）
(左上は空欄)  A  K  Q ... 2
A  AI AI ... 24
K  AI AI ... 9
...
※ 数値または 'AI' を入れてください。"></textarea>
              <div class="row" style="margin-top:8px;">
                <button class="btn btn-primary" id="applyGrid">貼り付けを反映</button>
                <button class="btn btn-danger" id="clearGrid">表データを消去</button>
              </div>
              <div class="smallNote" style="margin-top:6px;">
                ・区切りはタブ（TSV）でもカンマ（CSV）でもOK<br>
                ・AI は 80以上扱いとして強調表示
              </div>
            </div>
          </div>
        </div>

        <div class="swipeHint">左右スワイプで「入力／グラフ／ログ／パワー」を切り替えできます。</div>
      </div>
    </section>

  </div>
</div>

<div class="toast" id="toast">Saved</div>

<script>
(() => {
  const LS_KEY = "poker_stack_logger_final_v1";

  const POSITIONS = ["UTG","UTG+1","LJ","HJ","CO","BTN","SB","BB"];
  const RANKS = ["A","K","Q","J","T","9","8","7","6","5","4","3","2"];

  const el = (id) => document.getElementById(id);

  // Tabs/pages
  const tabsEl = el("tabs");
  const pagesEl = el("pages");
  const tabEls = Array.from(tabsEl.querySelectorAll(".tab"));

  // Inputs
  const inputs = {
    name: el("name"),
    chips: el("chips"),
    initial: el("initial"),
    busted: el("busted"),
    sb: el("sb"),
    bb: el("bb"),
    bbante: el("bbante"),
    memo: el("memo"),
    bbIs2sb: el("bbIs2sb"),
    anteIsBb: el("anteIsBb"),
    position: el("position"),

    // Chart filters
    chartName: el("chartName"),
    chartDate: el("chartDate"),
    chartReset: el("chartReset"),

    // Power reads
    behindRead: el("behindRead"),
    mRead: el("mRead"),
    powerRead: el("powerRead"),
  };

  const ui = {
    chipsBig: el("chipsBig"),
    difChips: el("difChips"),
    mValue: el("mValue"),
    behind: el("behind"),
    powerNum: el("powerNum"),

    record: el("record"),
    undo: el("undo"),
    clearAll: el("clearAll"),

    bustedMinus: el("bustedMinus"),
    bustedPlus: el("bustedPlus"),

    stepButtons: el("stepButtons"),

    chart: el("chart"),
    logBody: el("logBody"),
    copyCsv: el("copyCsv"),
    exportJson: el("exportJson"),
    importJson: el("importJson"),

    toast: el("toast"),

    // Power
    handGrid: el("handGrid"),
    showPaste: el("showPaste"),
    pasteArea: el("pasteArea"),
    gridPaste: el("gridPaste"),
    applyGrid: el("applyGrid"),
    clearGrid: el("clearGrid"),
  };

  const ctx = ui.chart.getContext("2d");

  const now = () => new Date();
  const pad2 = (n) => String(n).padStart(2, "0");
  const fmtDate = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  const fmtTime = (d) => `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
  const fmtInt = (n) => (Number.isFinite(n) ? Math.round(n).toLocaleString("ja-JP") : "-");
  const fmt1 = (n) => (Number.isFinite(n) ? (Math.round(n*10)/10).toFixed(1) : "-");

  const defaultState = {
    name: "",
    chips: 10000,
    initial: 10000,
    busted: 0,
    sb: 50,
    bb: 100,
    bbante: 0,
    memo: "",
    bbIs2sb: false,
    anteIsBb: false,

    position: "UTG",

    chartFilter: { name: "__ALL__", date: "__ALL__" },

    logs: [],

    // Power table data (user pasted)
    // stored as { "A-A": "AI" or number, ... }
    powerGrid: {}
  };

  let state = load();

  function load() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return structuredClone(defaultState);
      const parsed = JSON.parse(raw);

      if (!Array.isArray(parsed.logs)) parsed.logs = [];
      if (!parsed.chartFilter) parsed.chartFilter = { name:"__ALL__", date:"__ALL__" };
      if (!parsed.powerGrid || typeof parsed.powerGrid !== "object") parsed.powerGrid = {};

      return { ...structuredClone(defaultState), ...parsed };
    } catch {
      return structuredClone(defaultState);
    }
  }

  function save() { localStorage.setItem(LS_KEY, JSON.stringify(state)); }

  function numVal(input, fallback=0) {
    const v = Number(input.value);
    return Number.isFinite(v) ? v : fallback;
  }
  function clamp(n, min, max) { return Math.min(max, Math.max(min, n)); }

  function calcDif(chips, initial, bustedCount) {
    const ini = Math.max(0, initial || 0);
    const bust = Math.max(0, Math.floor(bustedCount || 0));
    return chips - ini - (bust * ini);
  }
  function calcM(chips, sb, bb, bbante) {
    const cost = (sb||0) + (bb||0) + (bbante||0);
    return (cost > 0) ? (chips / cost) : NaN;
  }
  function calcBehind(position) {
    const idx = POSITIONS.indexOf(position);
    if (idx < 0) return NaN;
    return Math.max(0, 7 - idx); // 8-max fixed
  }

  // ===== Nice rounding (2 significant digits)
  // ceil to 2 significant digits; handles negatives via sign.
  function ceilSig2(x) {
    if (!Number.isFinite(x) || x === 0) return 0;
    const sign = x < 0 ? -1 : 1;
    const v = Math.abs(x);
    const p = Math.floor(Math.log10(v));
    const scale = Math.pow(10, Math.max(0, p - 1)); // keep 2 sig digits
    const n = Math.ceil(v / scale) * scale;
    return sign * n;
  }
  function floorSig2(x) {
    if (!Number.isFinite(x) || x === 0) return 0;
    const sign = x < 0 ? -1 : 1;
    const v = Math.abs(x);
    const p = Math.floor(Math.log10(v));
    const scale = Math.pow(10, Math.max(0, p - 1));
    const n = Math.floor(v / scale) * scale;
    return sign * n;
  }

  // ===== Step buttons under Chips (±A/±B/±C)
  // Candidates based on current chips (like 10^n / 10^(n-1) / 10^(n-2))
  function computeStepTriplet(chips) {
    const c = Math.max(0, Math.floor(chips || 0));
    if (c < 100) return [100, 10, 1];
    const p = Math.floor(Math.log10(c));
    const a = Math.pow(10, p);       // e.g. 12400 -> 10000
    const b = Math.pow(10, p-1);     // 1000
    const d = Math.pow(10, p-2);     // 100
    return [a, b, d].map(x => Math.max(1, x));
  }

  // We freeze step set while user taps buttons; only update when chips is typed or log recorded
  let stepTriplet = computeStepTriplet(state.chips);

  function renderStepButtons() {
    ui.stepButtons.innerHTML = "";

    const [A,B,C] = stepTriplet;
    const mk = (label, delta) => {
      const btn = document.createElement("button");
      btn.className = "btn-mini btn-step";
      btn.textContent = label;
      btn.addEventListener("click", () => {
        state.chips = Math.max(0, state.chips + delta);
        inputs.chips.value = state.chips;
        recalcAndRender(false); // do not refresh triplet here
      });
      return btn;
    };

    // order: -A -B -C +C +B +A (your request)
    ui.stepButtons.appendChild(mk(`−${fmtInt(A)}`, -A));
    ui.stepButtons.appendChild(mk(`−${fmtInt(B)}`, -B));
    ui.stepButtons.appendChild(mk(`−${fmtInt(C)}`, -C));
    ui.stepButtons.appendChild(mk(`＋${fmtInt(C)}`, +C));
    ui.stepButtons.appendChild(mk(`＋${fmtInt(B)}`, +B));
    ui.stepButtons.appendChild(mk(`＋${fmtInt(A)}`, +A));
  }

  function refreshStepTripletFromChips() {
    stepTriplet = computeStepTriplet(state.chips);
    renderStepButtons();
  }

  // ===== Toast
  let toastTimer = null;
  function showToast(msg) {
    ui.toast.textContent = msg;
    ui.toast.classList.add("show");
    if (toastTimer) clearTimeout(toastTimer);
    toastTimer = setTimeout(() => ui.toast.classList.remove("show"), 1200);
  }

  // ===== Auto input toggles (BB=2SB, Ante=BB)
  function applyAutoLocks() {
    // BB = 2*SB => lock BB
    if (inputs.bbIs2sb.checked) {
      const sb = Math.max(0, numVal(inputs.sb, state.sb));
      const bb = sb * 2;
      inputs.bb.value = bb;
      inputs.bb.disabled = true;
      inputs.bb.classList.add("auto-off");
    } else {
      inputs.bb.disabled = false;
      inputs.bb.classList.remove("auto-off");
    }

    // Ante = BB => lock ante
    if (inputs.anteIsBb.checked) {
      const bb = Math.max(0, numVal(inputs.bb, state.bb));
      inputs.bbante.value = bb;
      inputs.bbante.disabled = true;
      inputs.bbante.classList.add("auto-off");
    } else {
      inputs.bbante.disabled = false;
      inputs.bbante.classList.remove("auto-off");
    }
  }

  // ===== Chart: canvas sizing & ticks
  function resizeCanvasToDisplaySize(canvas, ctx) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const displayWidth = Math.max(1, Math.round(rect.width * dpr));
    const displayHeight = Math.max(1, Math.round(rect.height * dpr));
    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
      canvas.width = displayWidth;
      canvas.height = displayHeight;
      ctx.setTransform(1,0,0,1,0,0);
    }
  }

  function getUniqueNames(logs) {
    const set = new Set();
    for (const r of logs) {
      const n = (r.name || "").trim();
      if (n) set.add(n);
    }
    return Array.from(set).sort((a,b)=>a.localeCompare(b,"ja"));
  }
  function getUniqueDatesForName(logs, name) {
    const set = new Set();
    for (const r of logs) {
      if (name !== "__ALL__" && ((r.name || "").trim() !== name)) continue;
      if (r.date) set.add(r.date);
    }
    return Array.from(set).sort().reverse();
  }
  function fillSelect(selectEl, items, currentValue, allLabel) {
    selectEl.innerHTML = "";
    const optAll = document.createElement("option");
    optAll.value = "__ALL__";
    optAll.textContent = allLabel;
    selectEl.appendChild(optAll);
    for (const v of items) {
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = v;
      selectEl.appendChild(opt);
    }
    const values = new Set(["__ALL__", ...items]);
    selectEl.value = values.has(currentValue) ? currentValue : "__ALL__";
  }
  function updateChartFilterUI() {
    const names = getUniqueNames(state.logs);
    fillSelect(inputs.chartName, names, state.chartFilter.name, "すべてのName");

    state.chartFilter.name = inputs.chartName.value;

    const dates = getUniqueDatesForName(state.logs, state.chartFilter.name);
    fillSelect(inputs.chartDate, dates, state.chartFilter.date, "すべての日付");
    state.chartFilter.date = inputs.chartDate.value;
  }
  function applyChartFilter(logs) {
    const f = state.chartFilter;
    return logs.filter(r => {
      if (f.name !== "__ALL__" && ((r.name || "").trim() !== f.name)) return false;
      if (f.date !== "__ALL__" && (r.date !== f.date)) return false;
      return true;
    });
  }

  function niceTickStep(range) {
    // range -> pick 2sig digit-ish step
    const r = Math.max(1, range);
    const raw = r / 4; // about 4 ticks
    const step = ceilSig2(raw);
    return Math.max(1, step);
  }

  // Chart range logic per your spec:
  // start 0..2*Initial; expand if observedMax > 0.8*Ymax => Ymax = ceilSig2(observedMax / 0.8)
  // and if observedMin < 0.8*Ymin => Ymin = floorSig2(observedMin / 0.8)
  // never shrink automatically.
  function computeChartRange(chipsArr, initial) {
    const observedMax = Math.max(...chipsArr);
    const observedMin = Math.min(...chipsArr);

    // base
    let yMin = 0;
    let yMax = Math.max(1, (Math.max(0, initial || 0) * 2));

    // expand up
    if (observedMax > 0.8 * yMax) {
      const target = observedMax / 0.8;
      yMax = ceilSig2(target);
      if (yMax === 0) yMax = 1;
    }

    // expand down (when negative happens)
    // For yMin=0, 0.8*yMin = 0, so any negative triggers.
    if (observedMin < 0.8 * yMin) {
      const target = observedMin / 0.8; // negative
      yMin = floorSig2(target);
    }

    // ensure not equal
    if (yMax <= yMin) yMax = yMin + 1;

    return { yMin, yMax };
  }

  function renderChart() {
    resizeCanvasToDisplaySize(ui.chart, ctx);
    const w = ui.chart.width, h = ui.chart.height;
    ctx.clearRect(0, 0, w, h);

    updateChartFilterUI();
    const filtered = applyChartFilter(state.logs);

    if (filtered.length < 2) {
      ctx.fillStyle = "#777";
      const fontPx = Math.max(14, Math.round(h * 0.06));
      ctx.font = `${fontPx}px -apple-system, system-ui, sans-serif`;
      ctx.fillText("ログが2件以上あると表示（フィルタ条件も確認）", 20, 60);
      return;
    }

    const data = [...filtered].sort((a,b) => (a.ts||0) - (b.ts||0));
    const chipsArr = data.map(x => x.chips);

    // plot area
    const pad = Math.round(Math.min(w,h) * 0.10);
    const topPad = Math.round(pad * 0.9);
    const innerW = w - pad*2;
    const innerH = h - (topPad + pad);

    const minTs = Math.min(...data.map(d => d.ts || 0));
    const maxTs = Math.max(...data.map(d => d.ts || 0));
    const spanTs = Math.max(1, maxTs - minTs);
    const xAt = (ts) => pad + innerW * ((ts - minTs) / spanTs);

    // range logic
    const { yMin, yMax } = computeChartRange(chipsArr, state.initial);
    const spanY = Math.max(1, yMax - yMin);
    const yAt = (v) => topPad + innerH * (1 - (v - yMin) / spanY);

    // ticks
    const tickFont = Math.max(12, Math.round(h * 0.04));
    ctx.font = `${tickFont}px -apple-system, system-ui, sans-serif`;
    ctx.fillStyle = "#666";

    // Y axis ticks
    const stepY = niceTickStep(spanY);
    const yStart = Math.ceil(yMin / stepY) * stepY;
    const yTicks = [];
    for (let v = yStart; v <= yMax + 0.0001; v += stepY) yTicks.push(v);

    // grid + y labels
    ctx.strokeStyle = "#e8e8e8";
    ctx.lineWidth = 1;
    for (const v of yTicks) {
      const y = yAt(v);
      ctx.beginPath();
      ctx.moveTo(pad, y);
      ctx.lineTo(w - pad, y);
      ctx.stroke();
      ctx.fillText(fmtInt(v), 8, y + Math.round(tickFont*0.35));
    }

    // X axis ticks (time)
    const tickCount = 5;
    const xTicks = [];
    for (let i=0;i<tickCount;i++){
      const t = minTs + spanTs * (i/(tickCount-1));
      xTicks.push(t);
    }

    // x labels + small vertical grid
    ctx.strokeStyle = "#f0f0f0";
    for (const t of xTicks) {
      const x = xAt(t);
      ctx.beginPath();
      ctx.moveTo(x, topPad);
      ctx.lineTo(x, topPad + innerH);
      ctx.stroke();
    }

    ctx.fillStyle = "#666";
    ctx.font = `${tickFont}px -apple-system, system-ui, sans-serif`;
    for (const t of xTicks) {
      // pick nearest actual log time (avoid weird labels)
      let nearest = data[0];
      let best = Math.abs((nearest.ts||0) - t);
      for (const r of data) {
        const d = Math.abs((r.ts||0) - t);
        if (d < best) { best = d; nearest = r; }
      }
      const x = xAt(nearest.ts);
      const label = `${nearest.time?.slice(0,5) || ""}`;
      ctx.save();
      ctx.translate(x, h - Math.round(tickFont*0.6));
      ctx.rotate(-Math.PI/8);
      ctx.fillText(label, -Math.round(tickFont*1.6), 0);
      ctx.restore();
    }

    // title (range)
    const titleFont = Math.max(14, Math.round(h * 0.05));
    ctx.fillStyle = "#555";
    ctx.font = `${titleFont}px -apple-system, system-ui, sans-serif`;
    const f = state.chartFilter;
    const label = `Chips（レンジ ${fmtInt(yMin)}〜${fmtInt(yMax)}） / 表示：${f.name==="__ALL__"?"All Name":f.name} / ${f.date==="__ALL__"?"All Date":f.date}`;
    ctx.fillText(label, pad, Math.round(titleFont*1.3));

    // line
    ctx.strokeStyle = "#111";
    ctx.lineWidth = Math.max(2, Math.round(h*0.01));
    ctx.beginPath();
    ctx.moveTo(xAt(data[0].ts), yAt(chipsArr[0]));
    for (let i=1;i<data.length;i++){
      ctx.lineTo(xAt(data[i].ts), yAt(chipsArr[i]));
    }
    ctx.stroke();

    // last point
    const last = data.length - 1;
    ctx.fillStyle = "#111";
    const r = Math.max(4, Math.round(h*0.02));
    ctx.beginPath();
    ctx.arc(xAt(data[last].ts), yAt(chipsArr[last]), r, 0, Math.PI*2);
    ctx.fill();
  }

  // ===== Logs
  function renderLogs() {
    ui.logBody.innerHTML = "";
    for (const r of state.logs) {
      const tr = document.createElement("tr");
      const td = (text, cls="") => {
        const t = document.createElement("td");
        t.textContent = text;
        if (cls) t.className = cls;
        return t;
      };
      tr.appendChild(td(r.name || "", ""));
      tr.appendChild(td(r.date || "", "mono"));
      tr.appendChild(td(r.time || "", "mono"));
      tr.appendChild(td(fmtInt(r.chips), "mono right"));
      tr.appendChild(td(fmtInt(r.initial), "mono right"));
      tr.appendChild(td(fmtInt(r.busted), "mono right"));
      tr.appendChild(td(fmtInt(r.dif), "mono right"));
      tr.appendChild(td(fmtInt(r.sb), "mono right"));
      tr.appendChild(td(fmtInt(r.bb), "mono right"));
      tr.appendChild(td(fmtInt(r.bbante), "mono right"));
      tr.appendChild(td(Number.isFinite(r.m) ? fmt1(r.m) : "-", "mono right"));
      tr.appendChild(td(r.memo || "", ""));
      ui.logBody.appendChild(tr);
    }
  }

  function logsToCsv() {
    const headers = ["Name","Date","Time","Chips","Initial","Busted","Dif","SB","BB","Ante","M","Memo"];
    const esc = (v) => {
      const s = String(v ?? "");
      if (s.includes(",") || s.includes('"') || s.includes("\n")) return `"${s.replace(/"/g, '""')}"`;
      return s;
    };
    const rows = state.logs.map(r => [
      r.name, r.date, r.time, r.chips, r.initial, r.busted, r.dif, r.sb, r.bb, r.bbante,
      Number.isFinite(r.m) ? (Math.round(r.m*10)/10) : "",
      (r.memo ?? "").replace(/\r?\n/g, " ")
    ]);
    return [headers.map(esc).join(","), ...rows.map(r => r.map(esc).join(","))].join("\n");
  }

  async function copyCsv() {
    try { await navigator.clipboard.writeText(logsToCsv()); showToast("CSVをコピーしました"); }
    catch { alert("コピーに失敗しました（権限/ブラウザ設定をご確認ください）。"); }
  }

  function downloadText(filename, text, type="text/plain") {
    const blob = new Blob([text], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function exportJson() {
    const nameBase = (state.name && state.name.trim()) ? state.name.trim() : "PokerStack";
    const safe = nameBase.replace(/[\\/:*?"<>|]/g, "_");
    downloadText(`${safe}_backup.json`, JSON.stringify(state, null, 2), "application/json");
    showToast("バックアップJSONを保存しました");
  }

  function importJson() {
    const inp = document.createElement("input");
    inp.type = "file";
    inp.accept = "application/json";
    inp.onchange = async () => {
      const file = inp.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const obj = JSON.parse(text);
        if (!obj || typeof obj !== "object") throw new Error("invalid");
        // minimal merge
        state = { ...structuredClone(defaultState), ...obj };
        if (!Array.isArray(state.logs)) state.logs = [];
        if (!state.chartFilter) state.chartFilter = { name:"__ALL__", date:"__ALL__" };
        if (!state.powerGrid || typeof state.powerGrid !== "object") state.powerGrid = {};
        save();
        bindToUI();
        recalcAndRender(true);
        showToast("復元しました");
      } catch {
        alert("JSONの読み込みに失敗しました。");
      }
    };
    inp.click();
  }

  // ===== Record
  function recordLog() {
    const d = now();
    const date = fmtDate(d);
    const time = fmtTime(d);

    const chips = state.chips;
    const initial = state.initial;
    const busted = state.busted;
    const sb = state.sb;
    const bb = state.bb;
    const bbante = state.bbante;
    const memo = (state.memo || "").trim();

    const dif = calcDif(chips, initial, busted);
    const m = calcM(chips, sb, bb, bbante);

    state.logs.unshift({
      name: state.name,
      date,
      time,
      chips,
      initial,
      busted,
      dif,
      sb,
      bb,
      bbante,
      m,
      ts: d.getTime(),
      memo
    });
    if (state.logs.length > 1200) state.logs.length = 1200;

    // refresh step candidates only on record (your preference)
    refreshStepTripletFromChips();

    save();
    recalcAndRender(true);
    showToast(`記録しました ✓  ${time}`);
  }

  // ===== Power grid
  function cellKey(r1, r2) { return `${r1}-${r2}`; }

  function getCellValue(rRow, rCol) {
    // grid uses ranks: header col = RANKS; row header = RANKS
    const key = cellKey(rRow, rCol);
    return state.powerGrid[key];
  }

  function parseCellValue(v) {
    const s = String(v ?? "").trim();
    if (!s) return null;
    if (s.toUpperCase() === "AI") return "AI";
    const n = Number(s);
    if (Number.isFinite(n)) return n;
    return null;
  }

  function buildHandGrid() {
    ui.handGrid.innerHTML = "";

    // header row
    const thead = document.createElement("tr");
    const th0 = document.createElement("th");
    th0.className = "left";
    th0.textContent = "";
    thead.appendChild(th0);
    for (const c of RANKS) {
      const th = document.createElement("th");
      th.textContent = c;
      thead.appendChild(th);
    }
    ui.handGrid.appendChild(thead);

    // rows
    for (const r of RANKS) {
      const tr = document.createElement("tr");

      const th = document.createElement("td");
      th.className = "left";
      th.textContent = r;
      tr.appendChild(th);

      for (const c of RANKS) {
        const td = document.createElement("td");
        const val = getCellValue(r,c);
        td.dataset.key = cellKey(r,c);
        td.textContent = (val === undefined || val === null) ? "" : String(val);

        tr.appendChild(td);
      }
      ui.handGrid.appendChild(tr);
    }
  }

  function highlightPowerGrid() {
    // Highlight if cell score >= Power
    const power = computePower();
    const tds = ui.handGrid.querySelectorAll("td[data-key]");
    tds.forEach(td => {
      td.classList.remove("cellHi", "cellAI", "cellLow");
      const raw = td.textContent.trim();
      if (!raw) return;

      if (raw.toUpperCase() === "AI") {
        td.classList.add("cellAI");
        // always highlight as can all-in
        td.classList.add("cellHi");
        return;
      }
      const n = Number(raw);
      if (!Number.isFinite(n)) return;

      if (Number.isFinite(power) && n >= power) td.classList.add("cellHi");
      if (n < 3) td.classList.add("cellLow");
    });
  }

  function applyPasteGrid(text) {
    // Expect matrix with headers; supports TSV or CSV
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
    if (lines.length < 3) throw new Error("not enough lines");

    // detect delimiter by first line
    const delim = (lines[0].includes("\t")) ? "\t" : ",";
    const rows = lines.map(l => l.split(delim).map(x => x.trim()));

    // first row: header ranks
    const hdr = rows[0].slice(1); // skip left-top
    // map header to columns in our ranks
    const colMap = {};
    for (let i=0;i<hdr.length;i++){
      const r = hdr[i].toUpperCase();
      colMap[r] = i+1; // index in row array
    }

    const newGrid = { ...state.powerGrid };

    for (let ri=1; ri<rows.length; ri++){
      const row = rows[ri];
      const rowRank = (row[0] || "").toUpperCase();
      if (!rowRank) continue;
      if (!RANKS.includes(rowRank)) continue;

      for (const colRank of RANKS) {
        const idx = colMap[colRank];
        if (!idx || idx >= row.length) continue;
        const parsed = parseCellValue(row[idx]);
        if (parsed === null) continue;
        newGrid[cellKey(rowRank, colRank)] = parsed;
      }
    }

    state.powerGrid = newGrid;
  }

  // ===== Page / Swipe navigation
  function setActivePage(pageId) {
    // tabs
    tabEls.forEach(t => t.classList.toggle("active", t.dataset.page === pageId));
    // pages
    Array.from(pagesEl.querySelectorAll(".page")).forEach(p => {
      p.classList.toggle("active", p.id === `page-${pageId}`);
    });
    // keep state? (not necessary)
    // re-render chart on show
    if (pageId === "chart") renderChart();
    if (pageId === "power") {
      buildHandGrid();
      highlightPowerGrid();
    }
  }

  tabEls.forEach(t => {
    t.addEventListener("click", () => setActivePage(t.dataset.page));
  });

  // Swipe detection (avoid edge gesture)
  let touchStartX = null;
  let touchStartY = null;
  let touchTargetIsInput = false;
  function isFormEl(elm) {
    if (!elm) return false;
    const tag = (elm.tagName || "").toLowerCase();
    return tag === "input" || tag === "textarea" || tag === "select" || tag === "button";
  }

  document.addEventListener("touchstart", (e) => {
    if (e.touches.length !== 1) return;
    const t = e.touches[0];
    const w = window.innerWidth || 0;
    // avoid extreme edges (iOS back gesture)
    if (t.clientX < 18 || t.clientX > w - 18) return;

    touchStartX = t.clientX;
    touchStartY = t.clientY;
    touchTargetIsInput = isFormEl(e.target);
  }, { passive: true });

  document.addEventListener("touchend", (e) => {
    if (touchStartX === null || touchStartY === null) return;
    if (touchTargetIsInput) { touchStartX = touchStartY = null; return; } // avoid conflict while editing

    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;

    touchStartX = touchStartY = null;

    if (Math.abs(dx) < 55) return;
    if (Math.abs(dx) < Math.abs(dy) * 1.8) return; // mostly horizontal

    const order = ["input","chart","logs","power"];
    const current = tabEls.findIndex(x => x.classList.contains("active"));
    let next = current;

    if (dx < 0) next = Math.min(order.length - 1, current + 1); // swipe left => next
    else next = Math.max(0, current - 1); // swipe right => prev

    setActivePage(order[next]);
  }, { passive: true });

  // ===== Core recompute/render
  function computePower() {
    const m = calcM(state.chips, state.sb, state.bb, state.bbante);
    const behind = calcBehind(state.position);
    const power = (Number.isFinite(m) && Number.isFinite(behind)) ? (m * behind) : NaN;
    return power;
  }

  function recalcAndRender(reRenderStepTriplet) {
    // Apply auto locks first (so values are coherent)
    applyAutoLocks();

    state.name = inputs.name.value ?? "";
    state.chips = Math.max(0, numVal(inputs.chips, state.chips));
    state.initial = Math.max(0, numVal(inputs.initial, state.initial));
    state.busted = Math.max(0, Math.floor(numVal(inputs.busted, state.busted)));

    state.sb = Math.max(0, numVal(inputs.sb, state.sb));
    state.bb = Math.max(0, numVal(inputs.bb, state.bb));
    state.bbante = Math.max(0, numVal(inputs.bbante, state.bbante));
    state.memo = inputs.memo.value ?? "";

    state.bbIs2sb = inputs.bbIs2sb.checked;
    state.anteIsBb = inputs.anteIsBb.checked;

    state.position = inputs.position.value;

    const dif = calcDif(state.chips, state.initial, state.busted);
    const m = calcM(state.chips, state.sb, state.bb, state.bbante);
    const behind = calcBehind(state.position);
    const power = computePower();

    ui.chipsBig.textContent = fmtInt(state.chips);
    ui.difChips.textContent = Number.isFinite(dif) ? fmtInt(dif) : "-";
    ui.mValue.textContent = Number.isFinite(m) ? fmt1(m) : "-";
    ui.behind.textContent = Number.isFinite(behind) ? fmtInt(behind) : "-";
    ui.powerNum.textContent = Number.isFinite(power) ? fmt1(power) : "-";

    inputs.behindRead.value = Number.isFinite(behind) ? String(behind) : "";
    inputs.mRead.value = Number.isFinite(m) ? fmt1(m) : "";
    inputs.powerRead.value = Number.isFinite(power) ? fmt1(power) : "";

    renderLogs();
    // chart & power grid render on page show, but keep updated too:
    renderChart();
    buildHandGrid();
    highlightPowerGrid();

    if (reRenderStepTriplet) {
      refreshStepTripletFromChips();
    }

    save();
  }

  // ===== Bind state to UI
  function bindToUI() {
    inputs.name.value = state.name;
    inputs.chips.value = state.chips;
    inputs.initial.value = state.initial;
    inputs.busted.value = state.busted;
    inputs.sb.value = state.sb;
    inputs.bb.value = state.bb;
    inputs.bbante.value = state.bbante;
    inputs.memo.value = state.memo;

    inputs.bbIs2sb.checked = !!state.bbIs2sb;
    inputs.anteIsBb.checked = !!state.anteIsBb;

    inputs.position.value = state.position;

    // chart filter restore
    // (will be corrected if options missing)
    inputs.chartName.value = state.chartFilter.name;
    inputs.chartDate.value = state.chartFilter.date;

    applyAutoLocks();

    // steps
    stepTriplet = computeStepTriplet(state.chips);
    renderStepButtons();

    // build grids
    buildHandGrid();
    highlightPowerGrid();
  }

  // ===== Events
  function wireEvents() {
    // When chips typed: refresh triplet (allowed)
    inputs.chips.addEventListener("input", () => {
      state.chips = Math.max(0, numVal(inputs.chips, state.chips));
      refreshStepTripletFromChips();
      recalcAndRender(false);
    });

    // Auto checkboxes
    inputs.bbIs2sb.addEventListener("change", () => {
      applyAutoLocks();
      recalcAndRender(false);
    });
    inputs.anteIsBb.addEventListener("change", () => {
      applyAutoLocks();
      recalcAndRender(false);
    });

    // SB/BB changes should cascade if auto toggled
    inputs.sb.addEventListener("input", () => { applyAutoLocks(); recalcAndRender(false); });
    inputs.bb.addEventListener("input", () => { applyAutoLocks(); recalcAndRender(false); });
    inputs.bbante.addEventListener("input", () => { applyAutoLocks(); recalcAndRender(false); });

    // Other fields
    ["name","initial","busted","memo"].forEach(k => {
      inputs[k].addEventListener("input", () => recalcAndRender(false));
      inputs[k].addEventListener("change", () => recalcAndRender(false));
    });

    // Busted +/- buttons
    ui.bustedMinus.addEventListener("click", () => {
      state.busted = Math.max(0, (state.busted|0) - 1);
      inputs.busted.value = state.busted;
      recalcAndRender(false);
    });
    ui.bustedPlus.addEventListener("click", () => {
      state.busted = Math.max(0, (state.busted|0) + 1);
      inputs.busted.value = state.busted;
      recalcAndRender(false);
    });

    // Record
    ui.record.addEventListener("click", () => recordLog());

    // Undo
    ui.undo.addEventListener("click", () => {
      if (state.logs.length === 0) return;
      state.logs.shift();
      save();
      recalcAndRender(true);
      showToast("直近ログを削除しました");
    });

    // Clear all
    ui.clearAll.addEventListener("click", () => {
      if (!confirm("すべてのログと設定を消去します。よろしいですか？")) return;
      localStorage.removeItem(LS_KEY);
      state = structuredClone(defaultState);
      bindToUI();
      recalcAndRender(true);
      showToast("全消去しました");
    });

    // Chart filters
    inputs.chartName.addEventListener("change", () => {
      state.chartFilter.name = inputs.chartName.value;
      // Date options depend on name
      updateChartFilterUI();
      renderChart();
      save();
    });
    inputs.chartDate.addEventListener("change", () => {
      state.chartFilter.date = inputs.chartDate.value;
      renderChart();
      save();
    });
    inputs.chartReset.addEventListener("click", () => {
      state.chartFilter = { name:"__ALL__", date:"__ALL__" };
      updateChartFilterUI();
      renderChart();
      save();
      showToast("表示リセット");
    });

    // Resize => redraw chart crisp
    window.addEventListener("resize", () => { renderChart(); }, { passive: true });

    // CSV / JSON
    ui.copyCsv.addEventListener("click", copyCsv);
    ui.exportJson.addEventListener("click", exportJson);
    ui.importJson.addEventListener("click", importJson);

    // Position for power
    inputs.position.addEventListener("change", () => {
      recalcAndRender(false);
      showToast("Position更新");
    });

    // Power paste area toggle
    ui.showPaste.addEventListener("click", () => {
      const open = ui.pasteArea.style.display !== "none";
      ui.pasteArea.style.display = open ? "none" : "block";
      ui.showPaste.textContent = open ? "▶ ここを押して貼り付け欄を開く（TSV/CSV）" : "▼ 貼り付け欄を閉じる";
    });

    ui.applyGrid.addEventListener("click", () => {
      try {
        applyPasteGrid(ui.gridPaste.value || "");
        save();
        buildHandGrid();
        highlightPowerGrid();
        showToast("表データを反映しました");
      } catch {
        alert("貼り付け形式を確認してください（TSV/CSV、ヘッダあり）。");
      }
    });

    ui.clearGrid.addEventListener("click", () => {
      if (!confirm("表データを消去します。よろしいですか？")) return;
      state.powerGrid = {};
      save();
      buildHandGrid();
      highlightPowerGrid();
      showToast("表データを消去しました");
    });
  }

  // ===== Init
  bindToUI();
  wireEvents();
  recalcAndRender(true);

  // Set default page
  setActivePage("input");

})();
</script>
</body>
</html>
